<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>실시간 자유 채팅방</title>
    <style>
      :root {
        font-family: 'Pretendard', 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        line-height: 1.6;
        color: #f5f7fb;
        background-color: #050915;
        text-rendering: optimizeLegibility;
        -webkit-font-smoothing: antialiased;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, rgba(64, 179, 255, 0.2), transparent 60%),
          radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.08), transparent 40%), #050915;
      }

      .page {
        max-width: 960px;
        margin: 0 auto;
        padding: 48px 20px 80px;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-bottom: 28px;
      }

      header h1 {
        margin: 0;
        font-size: clamp(2rem, 3vw, 2.8rem);
      }

      header p {
        margin: 0;
        color: #9fb3c8;
      }

      .actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .actions a,
      .actions button {
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 999px;
        padding: 10px 18px;
        background: transparent;
        color: inherit;
        text-decoration: none;
        cursor: pointer;
        transition: border-color 0.2s ease, color 0.2s ease;
        font-size: 0.95rem;
      }

      .actions a:hover,
      .actions button:hover {
        border-color: #71c4ff;
        color: #71c4ff;
      }

      .panel {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.07);
        border-radius: 18px;
        padding: 24px;
        box-shadow: 0 15px 60px rgba(15, 20, 30, 0.4);
        backdrop-filter: blur(8px);
        margin-bottom: 18px;
      }

      .panel h2 {
        margin: 0 0 8px;
        font-size: 1.2rem;
      }

      .panel-note {
        color: #9fb3c8;
        font-size: 0.95rem;
        margin: 0 0 14px;
      }

      .status-text {
        font-size: 0.95rem;
        color: #d6dfeb;
        margin: 0 0 14px;
      }

      .messages {
        max-height: 420px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding-right: 4px;
      }

      .message {
        padding: 14px 16px;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .message .meta {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        font-size: 0.85rem;
        color: #9fb3c8;
        margin-bottom: 6px;
      }

      .message .author {
        font-weight: 600;
        color: #f5f7fb;
      }

      .message .author.anonymous {
        color: #ffda79;
      }

      .empty {
        text-align: center;
        color: #9fb3c8;
        font-size: 0.95rem;
      }

      .error {
        color: #ffb3b3;
        font-size: 0.95rem;
        margin: 8px 0 0;
      }

      form {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-top: 16px;
      }

      textarea {
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 12px 14px;
        background: rgba(0, 0, 0, 0.25);
        color: #f5f7fb;
        font-size: 1rem;
        resize: vertical;
        min-height: 110px;
      }

      textarea:focus {
        outline: none;
        border-color: #71c4ff;
        box-shadow: 0 0 0 2px rgba(113, 196, 255, 0.15);
      }

      .form-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 0.9rem;
        color: #cdd7e8;
      }

      .toggle input {
        width: 18px;
        height: 18px;
        accent-color: #71c4ff;
      }

      .primary-btn {
        border: none;
        border-radius: 999px;
        padding: 10px 20px;
        font-size: 0.95rem;
        cursor: pointer;
        transition: opacity 0.2s ease, transform 0.1s ease;
        color: #050915;
        background: linear-gradient(135deg, #71c4ff, #3dd598);
      }

      .primary-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .primary-btn:not(:disabled):active {
        transform: scale(0.98);
      }

      .notice {
        padding: 14px 16px;
        border-radius: 12px;
        border: 1px dashed rgba(255, 255, 255, 0.25);
        background: rgba(255, 255, 255, 0.02);
        color: #cdd7e8;
        font-size: 0.95rem;
      }

      footer {
        margin-top: 48px;
        text-align: center;
        color: #6e7d94;
        font-size: 0.85rem;
      }

      @media (max-width: 640px) {
        .page {
          padding: 32px 16px 60px;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <header>
        <h1>실시간 자유 채팅방</h1>
        <p>로그인한 사용자는 익명 또는 아이디 공개로 대화에 참여할 수 있습니다.</p>
        <div class="actions">
          <a href="/">메인으로 돌아가기</a>
          <button type="button" id="refresh-btn">즉시 새로고침</button>
        </div>
      </header>

      <section class="panel">
        <h2>대화 목록</h2>
        <p class="panel-note">WebSocket 실시간 연결로 새 메시지가 자동으로 표시됩니다.</p>
        <p class="status-text" id="status-text">최근 대화 불러오는 중...</p>
        <div class="messages" id="chat-messages"></div>
        <p class="empty" id="empty-state" hidden>아직 대화가 없습니다. 첫 메시지를 남겨보세요!</p>
        <p class="error" id="chat-error" hidden></p>
      </section>

      <section class="panel">
        <h2>메시지 보내기</h2>
        <p class="panel-note">한 번에 최대 500자까지 입력할 수 있습니다.</p>
        <div class="notice" id="login-notice" hidden>
          로그인 정보가 필요합니다. <a href="/accounts" style="color: #71c4ff">계정 페이지</a>에서 로그인한 후 다시 돌아오세요.
        </div>
        <div class="notice" id="profile-box" hidden></div>
        <form id="chat-form">
          <textarea id="chat-input" name="chat-content" placeholder="지금 떠오르는 이야기를 적어보세요"></textarea>
          <div class="form-actions">
            <label class="toggle">
              <input type="checkbox" id="chat-anon" checked />
              <span>익명으로 보내기</span>
            </label>
            <button class="primary-btn" type="submit" id="send-btn" disabled>메시지 전송</button>
          </div>
          <p class="error" id="form-error" hidden></p>
        </form>
      </section>

      <footer>© 자유 채팅방 · Django REST API와 Vue SPA 기반</footer>
    </div>

    <script>
      ;(() => {
        const TOKEN_STORAGE_KEY = 'codex_auth_token'
        const DEFAULT_ROOM_NAME = '오픈 라운지'
        const HISTORY_LIMIT = 80
        const RECONNECT_DELAY = 3000
        const STATUS_MESSAGES = {
          idle: '실시간 연결을 준비 중입니다.',
          connecting: '채팅방 실시간 연결 중...',
          open: '실시간 연결이 완료되었습니다. 새 메시지는 자동으로 표시됩니다.',
          closed: '실시간 연결이 종료되었습니다. 재연결을 시도합니다...',
        }

        const chatMessagesEl = document.getElementById('chat-messages')
        const emptyStateEl = document.getElementById('empty-state')
        const chatErrorEl = document.getElementById('chat-error')
        const statusTextEl = document.getElementById('status-text')
        const formErrorEl = document.getElementById('form-error')
        const loginNoticeEl = document.getElementById('login-notice')
        const profileBoxEl = document.getElementById('profile-box')
        const chatFormEl = document.getElementById('chat-form')
        const textareaEl = document.getElementById('chat-input')
        const anonCheckboxEl = document.getElementById('chat-anon')
        const sendBtnEl = document.getElementById('send-btn')
        const refreshBtn = document.getElementById('refresh-btn')

        let token = null
        let currentUser = null
        let currentRoom = null
        let ws = null
        let wsState = 'idle'
        let shouldReconnect = false
        let reconnectTimer = null
        let messageList = []

        const resolveRuntimeBase = () => {
          const hostname = (window.location.hostname || '').toLowerCase()
          const isGithubHost = hostname.includes('github.io') || hostname.includes('githubusercontent.com')
          if (isGithubHost) {
            return window.API_BASE_URL || 'https://15-164-232-40.nip.io/api'
          }
          if (window.API_BASE_URL) return window.API_BASE_URL
          if (window.location.origin) {
            return `${window.location.origin}/api`
          }
          return '/api'
        }

        const API_BASE_URL = resolveRuntimeBase().replace(/\/$/, '')
        const buildUrl = (path) => `${API_BASE_URL}${path.startsWith('/') ? path : `/${path}`}`

        const determineWsOrigin = () => {
          try {
            const url = new URL(API_BASE_URL, window.location.origin)
            const protocol = url.protocol === 'https:' ? 'wss:' : 'ws:'
            return `${protocol}//${url.host}`
          } catch {
            if (!window.location?.host) return null
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
            return `${protocol}//${window.location.host}`
          }
        }

        const WS_ORIGIN = determineWsOrigin()

        const readToken = () => {
          try {
            token = window.localStorage?.getItem(TOKEN_STORAGE_KEY) || null
          } catch {
            token = null
          }
          return token
        }

        const setElementVisibility = (el, shouldShow) => {
          if (!el) return
          el.hidden = !shouldShow
        }

        const setTextOrHide = (el, message) => {
          if (!el) return
          if (!message) {
            el.textContent = ''
            el.hidden = true
            return
          }
          el.textContent = message
          el.hidden = false
        }

        const setStatusText = (message) => {
          if (statusTextEl) {
            statusTextEl.textContent = message || ''
          }
        }

        const setChatError = (message) => setTextOrHide(chatErrorEl, message)
        const setFormError = (message) => setTextOrHide(formErrorEl, message)

        const shouldStickToBottom = () => {
          if (!chatMessagesEl) return false
          const distance = chatMessagesEl.scrollHeight - (chatMessagesEl.scrollTop + chatMessagesEl.clientHeight)
          return distance < 40
        }

        const renderMessageList = ({ forceScroll = false } = {}) => {
          if (!chatMessagesEl) return
          const stick = forceScroll || shouldStickToBottom()
          chatMessagesEl.innerHTML = ''
          if (!messageList.length) {
            setElementVisibility(emptyStateEl, true)
            return
          }
          setElementVisibility(emptyStateEl, false)
          messageList.forEach((message) => {
            const wrapper = document.createElement('article')
            wrapper.className = 'message'

            const meta = document.createElement('div')
            meta.className = 'meta'

            const author = document.createElement('span')
            author.className = 'author'
            if (message.is_anonymous) {
              author.classList.add('anonymous')
            }
            author.textContent = message.display_name || (message.is_anonymous ? '익명' : '사용자')

            const timestamp = document.createElement('time')
            timestamp.textContent = new Intl.DateTimeFormat('ko-KR', {
              dateStyle: 'short',
              timeStyle: 'short',
            }).format(new Date(message.created_at))

            meta.appendChild(author)
            meta.appendChild(timestamp)

            const body = document.createElement('p')
            body.textContent = message.content

            wrapper.appendChild(meta)
            wrapper.appendChild(body)
            chatMessagesEl.appendChild(wrapper)
          })
          if (stick) {
            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight
          }
        }

        const resetMessages = () => {
          messageList = []
          renderMessageList({ forceScroll: true })
        }

        const updateSendAvailability = () => {
          const canSend =
            Boolean(currentUser && token && currentRoom && wsState === 'open' && textareaEl.value.trim())
          sendBtnEl.disabled = !canSend
        }

        const syncFormState = () => {
          const isLoggedIn = Boolean(currentUser && token)
          textareaEl.disabled = !isLoggedIn
          anonCheckboxEl.disabled = !isLoggedIn
          setElementVisibility(loginNoticeEl, !isLoggedIn)
          setElementVisibility(profileBoxEl, isLoggedIn)
          if (isLoggedIn && profileBoxEl) {
            profileBoxEl.textContent = `${currentUser.username} 님으로 접속 중입니다. (${currentUser.email || '이메일 정보 없음'})`
          } else if (profileBoxEl) {
            profileBoxEl.textContent = ''
          }
          updateSendAvailability()
        }

        const setRealtimeState = (state, detail) => {
          wsState = state
          setStatusText(detail || STATUS_MESSAGES[state] || '')
          updateSendAvailability()
        }

        const apiRequest = async (path, { method = 'GET', body } = {}) => {
          const headers = { Accept: 'application/json' }
          if (body !== undefined) {
            headers['Content-Type'] = 'application/json'
          }
          if (token) {
            headers.Authorization = `Token ${token}`
          }
          const response = await fetch(buildUrl(path), {
            method,
            headers,
            body: body !== undefined ? JSON.stringify(body) : undefined,
          })
          const rawText = await response.text()
          let payload = null
          if (rawText) {
            try {
              payload = JSON.parse(rawText)
            } catch {
              payload = null
            }
          }
          if (!response.ok) {
            const message = payload?.detail || `요청에 실패했습니다. (${response.status})`
            const error = new Error(message)
            error.payload = payload
            error.status = response.status
            throw error
          }
          return payload
        }

        const fetchProfile = async () => {
          if (!token) {
            currentUser = null
            syncFormState()
            return
          }
          try {
            const payload = await apiRequest('/accounts/profile')
            const profile = payload?.profile
            currentUser = profile?.user || null
          } catch (error) {
            console.warn('프로필 확인 실패', error)
            currentUser = null
            setChatError('로그인 정보가 만료되었습니다. 다시 로그인해 주세요.')
            try {
              window.localStorage?.removeItem(TOKEN_STORAGE_KEY)
            } catch {
              // ignore
            }
            token = null
          } finally {
            syncFormState()
          }
        }

        const ensurePublicRoom = async () => {
          setStatusText('채팅방 정보를 불러오는 중입니다...')
          const payload = await apiRequest('/chat/rooms')
          const rooms = Array.isArray(payload?.rooms) ? payload.rooms : []
          if (!rooms.length) {
            throw new Error('입장 가능한 공개 채팅방이 없습니다.')
          }
          let target =
            rooms.find((room) => room.name === DEFAULT_ROOM_NAME) ||
            rooms.find((room) => !room.is_private) ||
            rooms[0]
          if (!target) {
            throw new Error('채팅방을 찾지 못했습니다.')
          }
          if (target.is_member) {
            return target
          }
          const joinPayload = await apiRequest('/chat/rooms/join', {
            method: 'POST',
            body: { name: target.name },
          })
          return joinPayload?.room || target
        }

        const buildWsUrl = () => {
          if (!WS_ORIGIN || !currentRoom || !token) {
            return null
          }
          return `${WS_ORIGIN}/ws/chatrooms/${currentRoom.id}/?token=${encodeURIComponent(token)}`
        }

        const scheduleReconnect = () => {
          if (reconnectTimer) return
          reconnectTimer = window.setTimeout(() => {
            reconnectTimer = null
            if (shouldReconnect && token && currentRoom) {
              connectSocket()
            }
          }, RECONNECT_DELAY)
        }

        const disconnectSocket = (resetState = true) => {
          shouldReconnect = false
          if (reconnectTimer) {
            clearTimeout(reconnectTimer)
            reconnectTimer = null
          }
          if (ws) {
            try {
              ws.close()
            } catch {
              // ignore
            }
            ws = null
          }
          if (resetState) {
            setRealtimeState('idle')
          }
        }

        const handleSocketMessage = (event) => {
          try {
            const data = JSON.parse(event.data)
            if (data.event === 'history') {
              messageList = Array.isArray(data.messages) ? data.messages.slice(-HISTORY_LIMIT) : []
              renderMessageList({ forceScroll: true })
              setChatError('')
            } else if (data.event === 'message') {
              if (data.message) {
                messageList = [...messageList, data.message].slice(-HISTORY_LIMIT)
                renderMessageList()
              }
            } else if (data.event === 'error') {
              setChatError(data.detail || '실시간 채팅 오류가 발생했습니다.')
            }
          } catch (error) {
            console.error('WebSocket 메시지를 파싱하지 못했습니다.', error)
          }
        }

        const connectSocket = () => {
          if (!token || !currentRoom) return
          const url = buildWsUrl()
          if (!url) {
            setChatError('WebSocket 엔드포인트를 계산하지 못했습니다.')
            return
          }
          disconnectSocket(false)
          shouldReconnect = true
          setRealtimeState('connecting')
          ws = new WebSocket(url)
          ws.addEventListener('open', () => {
            setRealtimeState('open')
            try {
              ws.send(JSON.stringify({ action: 'fetch_history' }))
            } catch (error) {
              console.error('히스토리 요청 실패', error)
            }
          })
          ws.addEventListener('message', handleSocketMessage)
          ws.addEventListener('close', () => {
            ws = null
            if (shouldReconnect && token && currentRoom) {
              setRealtimeState('closed')
              scheduleReconnect()
            } else {
              setRealtimeState('idle')
            }
          })
          ws.addEventListener('error', (event) => {
            console.error('WebSocket error', event)
            setChatError('실시간 연결에 문제가 발생했습니다.')
          })
        }

        const sendRealtimeAction = (payload) => {
          if (!ws || ws.readyState !== WebSocket.OPEN) {
            connectSocket()
            setChatError('실시간 연결을 준비 중입니다. 잠시 후 다시 시도해 주세요.')
            return false
          }
          ws.send(JSON.stringify(payload))
          return true
        }

        const submitChat = (event) => {
          event.preventDefault()
          setFormError('')
          setChatError('')
          if (!currentUser || !token) {
            setFormError('로그인 후 이용해 주세요.')
            return
          }
          if (!currentRoom) {
            setFormError('입장 가능한 채팅방이 없습니다.')
            return
          }
          const content = textareaEl.value.trim()
          if (!content) {
            setFormError('메시지를 입력해 주세요.')
            updateSendAvailability()
            return
          }
          const payload = {
            action: 'send_message',
            content,
            is_anonymous: anonCheckboxEl.checked,
          }
          if (sendRealtimeAction(payload)) {
            textareaEl.value = ''
            updateSendAvailability()
          }
        }

        const refreshHistory = () => {
          setChatError('')
          if (!sendRealtimeAction({ action: 'fetch_history' })) {
            setStatusText('실시간 연결을 다시 시도합니다...')
          }
        }

        const prepareRealtime = async () => {
          if (!token || !currentUser) {
            setRealtimeState('idle', '로그인 후 실시간 채팅을 이용해 주세요.')
            return
          }
          try {
            currentRoom = await ensurePublicRoom()
            resetMessages()
            syncFormState()
            connectSocket()
          } catch (error) {
            console.error(error)
            currentRoom = null
            setChatError(error.message || '채팅방 정보를 준비하지 못했습니다.')
            disconnectSocket(true)
          }
        }

        const init = async () => {
          resetMessages()
          readToken()
          setRealtimeState('idle')
          await fetchProfile()
          if (token && currentUser) {
            await prepareRealtime()
          } else {
            setRealtimeState('idle', '로그인 후 실시간 채팅을 이용해 주세요.')
          }
        }

        textareaEl.addEventListener('input', updateSendAvailability)
        chatFormEl.addEventListener('submit', submitChat)
        refreshBtn.addEventListener('click', refreshHistory)

        window.addEventListener('storage', async (event) => {
          if (event.key !== TOKEN_STORAGE_KEY) return
          const previous = token
          readToken()
          if (!token) {
            currentUser = null
            currentRoom = null
            disconnectSocket(true)
            resetMessages()
            syncFormState()
            setRealtimeState('idle', '로그인 후 실시간 채팅을 이용해 주세요.')
            return
          }
          if (token !== previous) {
            await fetchProfile()
            await prepareRealtime()
          }
        })

        init()
      })()
    </script>
  </body>
</html>
